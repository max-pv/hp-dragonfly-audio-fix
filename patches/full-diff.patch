--- a/sound/soc/amd/ps/pci-ps.c
+++ b/sound/soc/amd/ps/pci-ps.c
@@ -112,6 +112,8 @@
 					break;
 				}
 				switch (adata->acp_rev) {
+				case 0x60:
+				case 0x6f:
 				case ACP63_PCI_REV:
 					adata->acp63_sdw0_dma_intr_stat[stream_id] = 1;
 					break;
@@ -126,6 +128,8 @@
 		}
 	}
 	switch (adata->acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV:
 		if (ext_intr_stat1 & ACP63_P1_AUDIO1_RX_THRESHOLD) {
 			writel(ACP63_P1_AUDIO1_RX_THRESHOLD,
@@ -335,6 +339,12 @@
 			mach->mach_params.links = mach->links;
 			mach->mach_params.link_mask = mach->link_mask;
 			mach->mach_params.subsystem_rev = acp_data->acp_rev;
+			mach->mach_params.subsystem_vendor = acp_data->subsystem_vendor;
+			mach->mach_params.subsystem_device = acp_data->subsystem_device;
+			mach->mach_params.subsystem_id_set = true;
+
+			dev_dbg(dev, "SSID %x%x\n", mach->mach_params.subsystem_vendor,
+				mach->mach_params.subsystem_device);
 			return mach;
 		}
 	}
@@ -431,7 +441,9 @@
 		is_dmic_dev = true;
 
 	if (acp_data->is_sdw_config) {
-		ret = acp_scan_sdw_devices(&pci->dev, ACP63_SDW_ADDR);
+		u64 sdw_addr = (acp_data->acp_rev < ACP63_PCI_REV) ?
+				ACP60_SDW_ADDR : ACP63_SDW_ADDR;
+		ret = acp_scan_sdw_devices(&pci->dev, sdw_addr);
 		if (!ret && acp_data->info.link_mask)
 			is_sdw_dev = true;
 	}
@@ -549,6 +561,8 @@
 		return -ENOMEM;
 
 	switch (adata->acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV:
 		acp63_hw_init_ops(adata->hw_ops);
 		break;
@@ -581,6 +595,8 @@
 
 	/* ACP PCI revision id check for ACP6.3, ACP7.0 & ACP7.1 platforms */
 	switch (pci->revision) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV:
 	case ACP70_PCI_REV:
 	case ACP71_PCI_REV:
@@ -617,6 +633,9 @@
 	adata->addr = addr;
 	adata->reg_range = ACP63_REG_END - ACP63_REG_START;
 	adata->acp_rev = pci->revision;
+	adata->subsystem_vendor = pci->subsystem_vendor;
+	adata->subsystem_device = pci->subsystem_device;
+
 	pci_set_master(pci);
 	pci_set_drvdata(pci, adata);
 	mutex_init(&adata->acp_lock);
--- a/sound/soc/amd/ps/acp63.h
+++ b/sound/soc/amd/ps/acp63.h
@@ -61,6 +61,7 @@
 
 #define ACP63_DMIC_ADDR			2
 #define ACP63_SDW_ADDR			5
+#define ACP60_SDW_ADDR			2
 #define AMD_SDW_MAX_MANAGERS		2
 
 /* time in ms for acp timeout */
@@ -370,6 +371,8 @@
 	u32 addr;
 	u32 reg_range;
 	u32 acp_rev;
+	u32 subsystem_vendor;
+	u32 subsystem_device;
 	u32 acp_sw_pad_keeper_en;
 	u32 acp_pad_pulldown_ctrl;
 	u16 acp63_sdw0_dma_intr_stat[ACP63_SDW0_DMA_MAX_STREAMS];
--- a/sound/soc/amd/ps/ps-sdw-dma.c
+++ b/sound/soc/amd/ps/ps-sdw-dma.c
@@ -247,6 +247,8 @@
 	u32 sdw_mem_window_offset;
 
 	switch (acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV:
 		switch (manager_instance) {
 		case ACP_SDW0:
@@ -360,6 +362,8 @@
 		return -EINVAL;
 	stream_id = stream->stream_id;
 	switch (sdw_data->acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV:
 		switch (stream->instance) {
 		case ACP_SDW0:
@@ -437,6 +441,8 @@
 
 	byte_count.bytescount = 0;
 	switch (acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV:
 		switch (stream->instance) {
 		case ACP_SDW0:
@@ -518,6 +524,8 @@
 	if (!stream)
 		return -EINVAL;
 	switch (sdw_data->acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV:
 		switch (stream->instance) {
 		case ACP_SDW0:
@@ -564,6 +572,8 @@
 	stream = substream->runtime->private_data;
 	stream_id = stream->stream_id;
 	switch (acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV:
 		switch (stream->instance) {
 		case ACP_SDW0:
@@ -777,7 +787,7 @@
 	struct sdw_dma_dev_data *sdw_data;
 
 	sdw_data = dev_get_drvdata(dev);
-	if (sdw_data->acp_rev == ACP63_PCI_REV)
+	if (sdw_data->acp_rev <= ACP63_PCI_REV)
 		return acp63_restore_sdw_dma_config(sdw_data);
 	else
 		return acp70_restore_sdw_dma_config(sdw_data);
--- a/sound/soc/amd/acp/amd-acp63-acpi-match.c
+++ b/sound/soc/amd/acp/amd-acp63-acpi-match.c
@@ -112,6 +112,30 @@
 	{}
 };
 
+static const struct snd_soc_acpi_adr_device rt1316_only_group_adr[] = {
+	{
+		.adr = 0x000030025D131601ull,
+		.num_endpoints = 1,
+		.endpoints = &spk_l_endpoint,
+		.name_prefix = "rt1316-1"
+	},
+	{
+		.adr = 0x000031025D131601ull,
+		.num_endpoints = 1,
+		.endpoints = &spk_r_endpoint,
+		.name_prefix = "rt1316-2"
+	},
+};
+
+static const struct snd_soc_acpi_link_adr acp63_rt1316_only[] = {
+	{
+		.mask = BIT(0),
+		.num_adr = ARRAY_SIZE(rt1316_only_group_adr),
+		.adr_d = rt1316_only_group_adr,
+	},
+	{}
+};
+
 struct snd_soc_acpi_mach snd_soc_acpi_amd_acp63_sof_sdw_machines[] = {
 	{
 		.link_mask = BIT(0) | BIT(1),
@@ -127,6 +151,11 @@
 struct snd_soc_acpi_mach snd_soc_acpi_amd_acp63_sdw_machines[] = {
 	{
 		.link_mask = BIT(0),
+		.links = acp63_rt1316_only,
+		.drv_name = "amd_sdw",
+	},
+	{
+		.link_mask = BIT(0),
 		.links = acp63_rt722_only,
 		.drv_name = "amd_sdw",
 	},
--- a/sound/soc/amd/acp/amd-sdw-acpi.c
+++ b/sound/soc/amd/acp/amd-sdw-acpi.c
@@ -36,6 +36,11 @@
 	ret = fwnode_property_read_u32_array(acpi_fwnode_handle(adev),
 					     "mipi-sdw-manager-list", &sdw_bitmap, 1);
 	if (ret) {
+		/* Try deprecated property name used by older BIOS */
+		ret = fwnode_property_read_u32_array(acpi_fwnode_handle(adev),
+						     "mipi-sdw-master-list", &sdw_bitmap, 1);
+	}
+	if (ret) {
 		dev_err(&adev->dev,
 			"Failed to read mipi-sdw-manager-list: %d\n", ret);
 		return -EINVAL;
--- a/sound/soc/amd/acp/acp-sdw-legacy-mach.c
+++ b/sound/soc/amd/acp/acp-sdw-legacy-mach.c
@@ -95,6 +95,14 @@
 		},
 		.driver_data = (void *)(ASOC_SDW_CODEC_SPKR),
 	},
+	{
+		.callback = soc_sdw_quirk_cb,
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "HP"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "HP Dragonfly Pro Laptop PC"),
+		},
+		.driver_data = (void *)(ASOC_SDW_CODEC_SPKR),
+	},
 	{}
 };
 
@@ -166,6 +174,8 @@
 		}
 
 		switch (amd_ctx->acp_rev) {
+		case 0x60:
+		case 0x6f:
 		case ACP63_PCI_REV:
 			ret = get_acp63_cpu_pin_id(ffs(soc_end->link_mask - 1),
 						   *be_id, &cpu_pin_id, dev);
@@ -278,6 +288,8 @@
 		return -ENOMEM;
 
 	switch (amd_ctx->acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV:
 	case ACP70_PCI_REV:
 	case ACP71_PCI_REV:
@@ -326,6 +338,8 @@
 		return -ENOMEM;
 
 	switch (amd_ctx->acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV:
 	case ACP70_PCI_REV:
 	case ACP71_PCI_REV:
@@ -358,12 +372,11 @@
 	int sdw_be_num = 0, dmic_num = 0;
 	struct asoc_sdw_mc_private *ctx = snd_soc_card_get_drvdata(card);
 	struct snd_soc_acpi_mach_params *mach_params = &mach->mach_params;
-	struct asoc_sdw_endpoint *soc_ends __free(kfree) = NULL;
-	struct asoc_sdw_dailink *soc_dais __free(kfree) = NULL;
 	struct snd_soc_codec_conf *codec_conf;
 	struct snd_soc_dai_link *dai_links;
 	int num_devs = 0;
 	int num_ends = 0;
+	int num_confs;
 	int num_links;
 	int be_id = 0;
 	int ret;
@@ -374,17 +387,21 @@
 		return ret;
 	}
 
+	num_confs = num_ends;
+
 	/* One per DAI link, worst case is a DAI link for every endpoint */
-	soc_dais = kcalloc(num_ends, sizeof(*soc_dais), GFP_KERNEL);
+	struct asoc_sdw_dailink *soc_dais __free(kfree) =
+		kcalloc(num_ends, sizeof(*soc_dais), GFP_KERNEL);
 	if (!soc_dais)
 		return -ENOMEM;
 
 	/* One per endpoint, ie. each DAI on each codec/amp */
-	soc_ends = kcalloc(num_ends, sizeof(*soc_ends), GFP_KERNEL);
+	struct asoc_sdw_endpoint *soc_ends __free(kfree) =
+		kcalloc(num_ends, sizeof(*soc_ends), GFP_KERNEL);
 	if (!soc_ends)
 		return -ENOMEM;
 
-	ret = asoc_sdw_parse_sdw_endpoints(card, soc_dais, soc_ends, &num_devs);
+	ret = asoc_sdw_parse_sdw_endpoints(card, soc_dais, soc_ends, &num_confs);
 	if (ret < 0)
 		return ret;
 
@@ -396,7 +413,7 @@
 
 	dev_dbg(dev, "sdw %d, dmic %d", sdw_be_num, dmic_num);
 
-	codec_conf = devm_kcalloc(dev, num_devs, sizeof(*codec_conf), GFP_KERNEL);
+	codec_conf = devm_kcalloc(dev, num_confs, sizeof(*codec_conf), GFP_KERNEL);
 	if (!codec_conf)
 		return -ENOMEM;
 
@@ -407,7 +424,7 @@
 		return -ENOMEM;
 
 	card->codec_conf = codec_conf;
-	card->num_configs = num_devs;
+	card->num_configs = num_confs;
 	card->dai_link = dai_links;
 	card->num_links = num_links;
 
@@ -463,6 +480,10 @@
 	card->late_probe = asoc_sdw_card_late_probe;
 
 	snd_soc_card_set_drvdata(card, ctx);
+	if (mach->mach_params.subsystem_id_set)
+		snd_soc_card_set_pci_ssid(card,
+					  mach->mach_params.subsystem_vendor,
+					  mach->mach_params.subsystem_device);
 
 	dmi_check_system(soc_sdw_quirk_table);
 
--- a/sound/soc/amd/yc/pci-acp6x.c
+++ b/sound/soc/amd/yc/pci-acp6x.c
@@ -6,6 +6,7 @@
  */
 
 #include <linux/pci.h>
+#include <linux/acpi.h>
 #include <linux/module.h>
 #include <linux/io.h>
 #include <linux/delay.h>
@@ -168,6 +169,13 @@
 		dev_dbg(&pci->dev, "acp6x pci device not found\n");
 		return -ENODEV;
 	}
+
+	/* Defer to pci-ps driver if SoundWire controller is described in ACPI */
+	if (ACPI_COMPANION(&pci->dev) &&
+	    acpi_find_child_device(ACPI_COMPANION(&pci->dev), 2, 0)) {
+		dev_dbg(&pci->dev, "SoundWire ACPI device found, deferring\n");
+		return -ENODEV;
+	}
 	if (pci_enable_device(pci)) {
 		dev_err(&pci->dev, "pci_enable_device failed\n");
 		return -ENODEV;
--- a/drivers/soundwire/amd_manager.c
+++ b/drivers/soundwire/amd_manager.c
@@ -485,6 +485,8 @@
 
 	dev_dbg(amd_manager->dev, "p_params->num:0x%x\n", p_params->num);
 	switch (amd_manager->acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV_ID:
 		switch (amd_manager->instance) {
 		case ACP_SDW0:
@@ -528,6 +530,8 @@
 	u32 offset_reg, lane_ctrl_ch_en_reg;
 
 	switch (amd_manager->acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV_ID:
 		switch (amd_manager->instance) {
 		case ACP_SDW0:
@@ -600,6 +604,8 @@
 	u32 lane_ctrl_ch_en_reg;
 
 	switch (amd_manager->acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV_ID:
 		switch (amd_manager->instance) {
 		case ACP_SDW0:
@@ -1025,6 +1031,8 @@
 	amd_manager->bus.controller_id = 0;
 	dev_dbg(dev, "acp_rev:0x%x\n", amd_manager->acp_rev);
 	switch (amd_manager->acp_rev) {
+	case 0x60:
+	case 0x6f:
 	case ACP63_PCI_REV_ID:
 		switch (amd_manager->instance) {
 		case ACP_SDW0:
--- a/drivers/soundwire/amd_init.c
+++ b/drivers/soundwire/amd_init.c
@@ -157,6 +157,8 @@
 		if (!(ctx->link_mask & BIT(i)))
 			continue;
 		amd_manager = dev_get_drvdata(&ctx->pdev[i]->dev);
+		if (!amd_manager)
+			return -ENODEV;
 		ret = amd_sdw_manager_start(amd_manager);
 		if (ret)
 			return ret;

